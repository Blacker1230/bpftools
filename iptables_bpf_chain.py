#!/usr/bin/env python

template = r'''
#!/bin/bash
#
# This script is ***AUTOGENERATED***
#
# To apply the iptables BPF rule run this script:
#
#    ./%(fname)s
#
# This script creates an ipset "%(ipsetname)s". You can manage it
# manually:
#
#     ipset add %(ipsetname)s %(sampleips)s
#
# To clean the iptables rule and ipset run:
#
#    ./%(fname)s --delete
#
#

set -o noclobber
set -o errexit
set -o nounset
set -o pipefail

: ${IPTABLES:="%(iptables)s"}
: ${IPSET:="ipset"}
: ${INPUTPLACE:="4"}
: ${DEFAULTINT:=`awk 'BEGIN {n=0} $2 == "00000000" {n=1; print $1; exit} END {if (n=0) {print "eth0"}}' /proc/net/route`}

main_match () {
    ${IPTABLES} \
        ${*} \
        -i ${DEFAULTINT} \
        -p udp --dport 53 \
        -m set --match-set %(ipsetname)s dst \
        -j %(chain)s
}

chain_create() {
    ${IPTABLES} -N %(chain)s
%(accept_cmds)s
%(drop_cmds)s
    ${IPTABLES} -A %(chain)s -j RETURN
}

chain_delete() {
    ${IPTABLES} -F %(chain)s
    ${IPTABLES} -X %(chain)s
}

if [ "$*" == "--delete" ]; then

    A=`(main_match -C INPUT || echo "error") 2>/dev/null`
    if [ "${A}" != "error" ]; then
        main_match -D INPUT
        chain_delete
    fi
    ${IPSET} -exist destroy %(ipsetname)s 2>/dev/null

else

    ${IPSET} -exist create %(ipsetname)s hash:net family %(ipsetfamily)s
    for IP in %(ips)s; do
        ${IPSET} -exist add %(ipsetname)s "$IP"
    done

    A=`(main_match -C INPUT || echo "error") 2>/dev/null`
    if [ "${A}" == "error" ]; then
        chain_create
        main_match -I INPUT ${INPUTPLACE}
    fi

fi
'''.lstrip()

import argparse
import os
import stat
import string
import sys

import gen_dns


parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=r'''

This program generates a bash script. The script when run will insert
(or remove) an iptable rule and ipset. The iptable rule drops traffic
that matches the BPF rule, which in turn is generated from given
parameters.


'''.strip())
parser.add_argument('-6', '--inet6', action='store_true',
                    help='generate script for IPv6')
parser.add_argument('-i', '--ips', metavar='ips',
                    help='preset ips in the set')
parser.add_argument('-n', '--name', metavar='name',
                    help='name the generated script')
parser.add_argument('-a', '--accept', metavar='accept',
                    help='accept domains')
parser.add_argument('-d', '--drop', metavar='drop',
                    help='drop domains')

args = parser.parse_args()

if not args.name:
    print "set name with -n"
    sys.exit(-1)

inet = 4 if not args.inet6 else 6

fname = args.name +'_ip'+str(inet)+'.sh'

meta = []
for action, list_of_patterns in [('ACCEPT', args.accept), ('DROP', args.drop)]:
    cmds = []
    for domain in list_of_patterns.split():
        gen = gen_dns.generate(['-i', domain], inet=inet, l3off=0)

        if int(gen.bytecode.split(',')[0]) > 63:
            raise Exception("bytecode too long!")

        cmd = r'''
    ${IPTABLES} \
        -A %s \
        -m bpf --bytecode "%s" \
        -m comment --comment "%s" \
        -j %s
''' % (args.name.upper(), gen.bytecode, domain, action)
        cmds.append(cmd.strip('\n'))
    meta.append(cmds)

accept_cmds = meta[0]
drop_cmds = meta[1]

ctx = {
    'accept_cmds': '\n'.join(accept_cmds),
    'drop_cmds':  '\n'.join(drop_cmds),
    'fname': fname,
    'ipsetname': args.name + '_ip' + str(inet),
    'chain': args.name.upper(),
    'ips': ' '.join(repr(s) for s in args.ips.split()),
}

if inet == 4:
    ctx.update({
            'iptables': 'iptables',
            'ipsetfamily': 'inet',
            'sampleips': '1.1.1.1/32',
            })
else:
    ctx.update({
            'iptables': 'ip6tables',
            'ipsetfamily': 'inet6',
            'sampleips': '2a00:1450:4009:803::1008/128',
            })

f = open(fname, 'wb')
f.write(template % ctx)
f.flush()
print "Generated file %r" % (fname,)
os.chmod(fname, 0750)

